{"ast":null,"code":"var _jsxFileName = \"D:\\\\CSIT WEBSITES\\\\csit-website\\\\src\\\\Components\\\\MainMap.js\";\nimport React from 'react';\nimport mapboxgl from 'mapbox-gl';\nmapboxgl.accessToken = 'pk.eyJ1IjoiYXF1YWltcGFjdCIsImEiOiJja2R0d2N3emswdzlwMnptcGliNTk4ZHNkIn0.jPYEzZD-aErgL25Zx9N_Kg';\nlet map;\nlet counter = 0;\nlet popup;\nlet source;\n\nclass MainMap extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      lng: 103.851959,\n      lat: 1.290270,\n      zoom: 10.5,\n      souceColors: {}\n    };\n    this.mapContainer = React.createRef();\n  }\n\n  componentDidMount() {\n    map = new mapboxgl.Map({\n      container: this.mapContainer,\n      style: 'mapbox://styles/mapbox/streets-v11',\n      center: [this.state.lng, this.state.lat],\n      zoom: this.state.zoom\n    }); // Create a popup, but don't add it to the map yet.\n\n    var popup2 = new mapboxgl.Popup({\n      closeButton: false,\n      closeOnClick: false\n    });\n    popup = popup2;\n    var size = 200;\n    var pulsingDot = {\n      width: size,\n      height: size,\n      data: new Uint8Array(size * size * 4),\n      // get rendering context for the map canvas when layer is added to the map\n      onAdd: function () {\n        var canvas = document.createElement('canvas');\n        canvas.width = this.width;\n        canvas.height = this.height;\n        this.context = canvas.getContext('2d');\n      },\n      // called once before every frame where the icon will be used\n      render: function () {\n        var duration = 1000;\n        var t = performance.now() % duration / duration;\n        var radius = size / 2 * 0.3;\n        var outerRadius = size / 2 * 0.7 * t + radius;\n        var context = this.context; // draw outer circle\n\n        context.clearRect(0, 0, this.width, this.height);\n        context.beginPath();\n        context.arc(this.width / 2, this.height / 2, outerRadius, 0, Math.PI * 2);\n        context.fillStyle = 'rgba(255, 200, 200,' + (1 - t) + ')';\n        context.fill(); // draw inner circle\n\n        context.beginPath();\n        context.arc(this.width / 2, this.height / 2, radius, 0, Math.PI * 2);\n        context.fillStyle = 'rgba(255, 100, 100, 1)';\n        context.strokeStyle = 'white';\n        context.lineWidth = 2 + 4 * (1 - t);\n        context.fill();\n        context.stroke(); // update this image's data with data from the canvas\n\n        this.data = context.getImageData(0, 0, this.width, this.height).data; // continuously repaint the map, resulting in the smooth animation of the dot\n\n        map.triggerRepaint(); // return `true` to let the map know that the image was updated\n\n        return true;\n      }\n    };\n    map.addImage('pulsing-dot', pulsingDot, {\n      pixelRatio: 2\n    });\n  }\n\n  static generateColor() {\n    let n = (Math.random() * 0xfffff * 1000000).toString(16);\n    return '#' + n.slice(0, 6);\n  }\n\n  static getDatetime(datetime, selection) {\n    // 20/7/2020 8:00\n    let date = datetime.split(\" \");\n    let fulldate = date[0].split(\"/\");\n    let mon = fulldate[1];\n    let day = fulldate[0];\n    let year = fulldate[2];\n    let fullTime = date[1].split(\":\");\n    let hh = fullTime[0];\n    let min = fullTime[1]; // const monthNames = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n\n    const shortmonthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sept\", \"Oct\", \"Nov\", \"Dec\"];\n    let finalDatetime;\n\n    if (selection === \"d\") {\n      finalDatetime = day + \" \" + shortmonthNames[parseInt(mon) - 1] + \" \" + year;\n    } else if (selection === \"t\") {\n      let timing = \"AM\";\n\n      if (parseInt(hh) === 12) {\n        timing = \"PM\";\n      }\n\n      if (parseInt(hh) > 12) {\n        hh = parseInt(hh) - 12;\n        timing = \"PM\";\n      }\n\n      finalDatetime = hh + \":\" + min + \" \" + timing;\n    } // else if(selection == \"dt\"){\n    //     finalDatetime = new Date(datetime)\n    // }\n\n\n    return finalDatetime;\n  }\n\n  static getDerivedStateFromProps(props, state) {\n    source = {}; // console.log(map.style.sourceCaches);\n\n    if (props.profile.length > 0 && props.movement.length > 0) {\n      let mappedResults = props.profile.map(x => {\n        return {\n          profile: x,\n          movements: props.movement.filter(xx => xx.suspectId === x.id)\n        };\n      }); // Accepts the array and key\n\n      const groupBy = (array, key) => {\n        // Return the end result\n        return array.reduce((result, currentValue) => {\n          // If an array already present for key, push it to the array. Else create an array and push the object\n          (result[currentValue[key]] = result[currentValue[key]] || []).push(currentValue); // Return the current iteration `result` value, this will be taken as next iteration `result` value and accumulate\n\n          return result;\n        }, {}); // empty object is the initial value for result object\n      }; // Group by location address as key to the person array\n\n\n      const personGroupedByColor = groupBy(props.movement, 'locationShortaddress'); // console.log(personGroupedByColor)\n\n      var UPoints = Object.keys(personGroupedByColor).map(function (key) {\n        if (personGroupedByColor[key].length === 1) {\n          let item = personGroupedByColor[key][0];\n          return {\n            'type': 'Feature',\n            'properties': {\n              'movementID': item.id,\n              'enter': item.datetimeEntered,\n              'leave': item.datetimeLeft,\n              'placeID': item.locationShortaddress,\n              'marker-symbol': '1',\n              'marker-color': '#3bb2d0',\n              'marker-size': 'large',\n              'description': `<strong>${item.locationShortaddress}</strong><p>Time Entered: ${MainMap.getDatetime(item.datetimeEntered, 't')}</p><p>Time Left: ${MainMap.getDatetime(item.datetimeLeft, 't')}</p><p>Date: ${MainMap.getDatetime(item.datetimeLeft, 'd')}</p>`\n            },\n            'geometry': {\n              'type': 'Point',\n              'coordinates': [item.locationLong, item.locationLat]\n            }\n          };\n        } else {\n          let movementID = personGroupedByColor[key].map(x => x.id); // console.log(movementID)\n\n          let enter = personGroupedByColor[key].map(x => x.datetimeEntered);\n          let leave = personGroupedByColor[key].map(x => x.datetimeLeft);\n          let placeID = key;\n          let text = `<strong>${key}</strong>`; // console.log(placeID)\n\n          personGroupedByColor[key].forEach(xx => {\n            let name = props.profile.filter(x => x.id === xx.suspectId).map(x => {\n              return x.firstName + \" \" + x.lastName;\n            });\n            text += `<p>${name}</p>`;\n            text += `<p>Time Entered: ${MainMap.getDatetime(xx.datetimeEntered, 't')}</p><p>Time Left: ${MainMap.getDatetime(xx.datetimeLeft, 't')}</p><p>Date: ${MainMap.getDatetime(xx.datetimeLeft, 'd')}</p>`;\n          }); // console.log(text)\n          // let description = `<strong>${item.locationShortaddress}</strong><p>Time Entered: ${that.getDatetime(item.datetimeEntered, 't')}</p><p>Time Left: ${that.getDatetime(item.datetimeLeft, 't')}</p><p>Date: ${that.getDatetime(item.datetimeLeft, 'd')}</p>`\n\n          return {\n            'type': 'Feature',\n            'properties': {\n              'movementID': movementID,\n              'enter': enter,\n              'leave': leave,\n              'placeID': placeID,\n              'description': text\n            },\n            'geometry': {\n              'type': 'Point',\n              'coordinates': [personGroupedByColor[key][0].locationLong, personGroupedByColor[key][0].locationLat]\n            }\n          };\n        }\n      });\n\n      for (var key in map.style.sourceCaches) {\n        console.log(key);\n\n        if (key != 'composite') {\n          map.removeLayer(key);\n\n          if (key == \"placeIDs\") {\n            map.off('click', 'placeIDs', function (e) {\n              var placeID = e.features[0].properties.placeID;\n              var description = e.features[0].properties.description;\n              var movementID = e.features[0].properties.movementID;\n              var enter = e.features[0].properties.enter;\n              var leave = e.features[0].properties.leave;\n              props.dataRetrieved(movementID);\n            });\n            map.off('mouseenter', 'placeIDs', function (e) {\n              // Change the cursor style as a UI indicator.\n              map.getCanvas().style.cursor = 'pointer';\n              var coordinates = e.features[0].geometry.coordinates.slice();\n              var description = e.features[0].properties.description; // Ensure that if the map is zoomed out such that multiple\n              // copies of the feature are visible, the popup appears\n              // over the copy being pointed to.\n\n              while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {\n                coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;\n              } // Populate the popup and set its coordinates\n              // based on the feature found.\n\n\n              popup.setLngLat(coordinates).setHTML(description).addTo(map);\n            });\n            map.off('mouseleave', 'placeIDs', function () {\n              map.getCanvas().style.cursor = '';\n              popup.remove();\n            });\n          }\n\n          map.removeSource(key);\n        } // console.log(map.getStyle().layers)\n\n      }\n\n      mappedResults.forEach(e => {\n        let lol = Math.floor(Math.random() * 101).toString();\n        let UMovements = e.movements.map(x => {\n          return [x.locationLong, x.locationLat];\n        });\n        map.addSource(lol, {\n          'type': 'geojson',\n          'data': {\n            'type': 'Feature',\n            'properties': {},\n            'geometry': {\n              'type': 'LineString',\n              'coordinates': UMovements\n            }\n          }\n        });\n        let color = MainMap.generateColor();\n        source = { ...source,\n          [color]: e.profile.firstName + \" \" + e.profile.lastName\n        };\n        map.addLayer({\n          'id': lol,\n          'type': 'line',\n          'source': lol,\n          'layout': {\n            'line-join': 'round',\n            'line-cap': 'round'\n          },\n          'paint': {\n            'line-color': color,\n            'line-width': 5\n          }\n        });\n      });\n      map.addSource('placeIDs', {\n        'type': 'geojson',\n        'data': {\n          'type': 'FeatureCollection',\n          'features': UPoints\n        }\n      }); // Add a layer showing the places.\n\n      map.addLayer({\n        'id': 'placeIDs',\n        'type': 'symbol',\n        'source': 'placeIDs',\n        'layout': {\n          // \"line-cap\": \"round\",\n          // \"line-join\": \"round\"\n          'icon-image': 'pulsing-dot',\n          'icon-allow-overlap': true\n        }\n      });\n      map.on('click', 'placeIDs', function (e) {\n        var movementID = e.features[0].properties.movementID;\n        props.dataRetrieved(movementID);\n      });\n      map.on('mouseenter', 'placeIDs', function (e) {\n        // Change the cursor style as a UI indicator.\n        map.getCanvas().style.cursor = 'pointer';\n        var coordinates = e.features[0].geometry.coordinates.slice();\n        var description = e.features[0].properties.description; // Ensure that if the map is zoomed out such that multiple\n        // copies of the feature are visible, the popup appears\n        // over the copy being pointed to.\n\n        while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {\n          coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;\n        } // Populate the popup and set its coordinates\n        // based on the feature found.\n\n\n        popup.setLngLat(coordinates).setHTML(description).addTo(map);\n      });\n      map.on('mouseleave', 'placeIDs', function () {\n        map.getCanvas().style.cursor = '';\n        popup.remove();\n      });\n      counter += 1;\n    }\n\n    return true;\n  }\n\n  render() {\n    let legend = [];\n\n    for (var key in source) {\n      legend.push( /*#__PURE__*/React.createElement(\"div\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 400,\n          columnNumber: 17\n        }\n      }, /*#__PURE__*/React.createElement(\"span\", {\n        style: {\n          height: \"18px\",\n          width: \"18px\",\n          backgroundColor: \"#bbb\",\n          borderRadius: \"50%\",\n          display: \"inline-block\"\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 401,\n          columnNumber: 22\n        }\n      }), /*#__PURE__*/React.createElement(\"h5\", {\n        style: {\n          display: \"inline-block\",\n          marginLeft: \"10px\"\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 402,\n          columnNumber: 22\n        }\n      }, \"Testing\")));\n    }\n\n    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 408,\n        columnNumber: 17\n      }\n    }, /*#__PURE__*/React.createElement(\"span\", {\n      style: {\n        height: \"18px\",\n        width: \"18px\",\n        backgroundColor: \"#bbb\",\n        borderRadius: \"50%\",\n        display: \"inline-block\"\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 412,\n        columnNumber: 21\n      }\n    }), /*#__PURE__*/React.createElement(\"h5\", {\n      style: {\n        display: \"inline-block\",\n        marginLeft: \"10px\"\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 413,\n        columnNumber: 21\n      }\n    }, \"Testing\")), /*#__PURE__*/React.createElement(\"div\", {\n      style: {\n        position: \"relative\",\n        height: \"700px\",\n        width: \"100%\"\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 415,\n        columnNumber: 17\n      }\n    }, /*#__PURE__*/React.createElement(\"div\", {\n      ref: el => this.mapContainer = el,\n      style: {\n        position: \"reletive\",\n        width: \"inherit\",\n        height: \"inherit\"\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 416,\n        columnNumber: 21\n      }\n    })));\n  }\n\n}\n\nexport default MainMap;","map":{"version":3,"sources":["D:/CSIT WEBSITES/csit-website/src/Components/MainMap.js"],"names":["React","mapboxgl","accessToken","map","counter","popup","source","MainMap","Component","constructor","props","state","lng","lat","zoom","souceColors","mapContainer","createRef","componentDidMount","Map","container","style","center","popup2","Popup","closeButton","closeOnClick","size","pulsingDot","width","height","data","Uint8Array","onAdd","canvas","document","createElement","context","getContext","render","duration","t","performance","now","radius","outerRadius","clearRect","beginPath","arc","Math","PI","fillStyle","fill","strokeStyle","lineWidth","stroke","getImageData","triggerRepaint","addImage","pixelRatio","generateColor","n","random","toString","slice","getDatetime","datetime","selection","date","split","fulldate","mon","day","year","fullTime","hh","min","shortmonthNames","finalDatetime","parseInt","timing","getDerivedStateFromProps","profile","length","movement","mappedResults","x","movements","filter","xx","suspectId","id","groupBy","array","key","reduce","result","currentValue","push","personGroupedByColor","UPoints","Object","keys","item","datetimeEntered","datetimeLeft","locationShortaddress","locationLong","locationLat","movementID","enter","leave","placeID","text","forEach","name","firstName","lastName","sourceCaches","console","log","removeLayer","off","e","features","properties","description","dataRetrieved","getCanvas","cursor","coordinates","geometry","abs","lngLat","setLngLat","setHTML","addTo","remove","removeSource","lol","floor","UMovements","addSource","color","addLayer","on","legend","backgroundColor","borderRadius","display","marginLeft","position","el"],"mappings":"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","sourcesContent":["import React from 'react'\r\nimport mapboxgl from 'mapbox-gl';\r\n\r\nmapboxgl.accessToken = 'pk.eyJ1IjoiYXF1YWltcGFjdCIsImEiOiJja2R0d2N3emswdzlwMnptcGliNTk4ZHNkIn0.jPYEzZD-aErgL25Zx9N_Kg';\r\n\r\nlet map\r\nlet counter = 0\r\nlet popup\r\nlet source;\r\n\r\n\r\nclass MainMap extends React.Component{\r\n    \r\n    constructor(props){\r\n        super(props)\r\n\r\n        this.state = {\r\n            lng: 103.851959,\r\n            lat: 1.290270,\r\n            zoom: 10.5,\r\n            souceColors: {},\r\n        };\r\n\r\n        this.mapContainer = React.createRef();\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n        \r\n        map = new mapboxgl.Map({\r\n            container: this.mapContainer,\r\n            style: 'mapbox://styles/mapbox/streets-v11',\r\n            center: [this.state.lng, this.state.lat],\r\n            zoom: this.state.zoom\r\n        });\r\n\r\n        // Create a popup, but don't add it to the map yet.\r\n        var popup2 = new mapboxgl.Popup({\r\n            closeButton: false,\r\n            closeOnClick: false\r\n        });\r\n\r\n        popup = popup2\r\n\r\n        var size = 200\r\n\r\n        var pulsingDot = {\r\n            width: size,\r\n            height: size,\r\n            data: new Uint8Array(size * size * 4),\r\n             \r\n            // get rendering context for the map canvas when layer is added to the map\r\n            onAdd: function () {\r\n                var canvas = document.createElement('canvas');\r\n                canvas.width = this.width;\r\n                canvas.height = this.height;\r\n                this.context = canvas.getContext('2d');\r\n            },\r\n             \r\n            // called once before every frame where the icon will be used\r\n            render: function () {\r\n                var duration = 1000;\r\n                var t = (performance.now() % duration) / duration;\r\n                \r\n                var radius = (size / 2) * 0.3;\r\n                var outerRadius = (size / 2) * 0.7 * t + radius;\r\n                var context = this.context;\r\n                \r\n                // draw outer circle\r\n                context.clearRect(0, 0, this.width, this.height);\r\n                context.beginPath();\r\n                context.arc(\r\n                    this.width / 2,\r\n                    this.height / 2,\r\n                    outerRadius,\r\n                    0,\r\n                    Math.PI * 2\r\n                );\r\n            context.fillStyle = 'rgba(255, 200, 200,' + (1 - t) + ')';\r\n            context.fill();\r\n             \r\n            // draw inner circle\r\n            context.beginPath();\r\n            context.arc(\r\n            this.width / 2,\r\n            this.height / 2,\r\n            radius,\r\n            0,\r\n            Math.PI * 2\r\n            );\r\n            context.fillStyle = 'rgba(255, 100, 100, 1)';\r\n            context.strokeStyle = 'white';\r\n            context.lineWidth = 2 + 4 * (1 - t);\r\n            context.fill();\r\n            context.stroke();\r\n             \r\n            // update this image's data with data from the canvas\r\n            this.data = context.getImageData(\r\n            0,\r\n            0,\r\n            this.width,\r\n            this.height\r\n            ).data;\r\n             \r\n            // continuously repaint the map, resulting in the smooth animation of the dot\r\n            map.triggerRepaint();\r\n             \r\n            // return `true` to let the map know that the image was updated\r\n            return true;\r\n            }\r\n        };\r\n\r\n        map.addImage('pulsing-dot', pulsingDot, { pixelRatio: 2 });\r\n    }\r\n\r\n    static generateColor(){\r\n        let n = (Math.random() * 0xfffff * 1000000).toString(16);\r\n        return '#' + n.slice(0, 6);\r\n    }\r\n\r\n    static getDatetime(datetime, selection){\r\n\r\n        // 20/7/2020 8:00\r\n        let date = datetime.split(\" \")\r\n        let fulldate = date[0].split(\"/\")\r\n        \r\n\r\n        let mon = fulldate[1]\r\n        let day = fulldate[0]\r\n        let year = fulldate[2]\r\n        let fullTime = date[1].split(\":\")\r\n        let hh = fullTime[0]\r\n        let min = fullTime[1]\r\n\r\n        // const monthNames = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\r\n        const shortmonthNames = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sept\", \"Oct\", \"Nov\", \"Dec\"];\r\n\r\n        let finalDatetime\r\n        if(selection === \"d\"){\r\n            finalDatetime = day + \" \" + shortmonthNames[parseInt(mon)-1] + \" \" + year\r\n        }\r\n        else if(selection === \"t\"){\r\n            let timing = \"AM\"\r\n            if(parseInt(hh) === 12){\r\n                timing = \"PM\"\r\n            }\r\n            if(parseInt(hh) > 12){\r\n                hh = parseInt(hh) - 12\r\n                timing = \"PM\"\r\n            }\r\n            finalDatetime = hh + \":\" + min + \" \" + timing\r\n        }\r\n        // else if(selection == \"dt\"){\r\n        //     finalDatetime = new Date(datetime)\r\n        // }\r\n        return finalDatetime\r\n    }\r\n\r\n    static getDerivedStateFromProps(props, state){\r\n\r\n        source = {}\r\n        // console.log(map.style.sourceCaches);\r\n        if(props.profile.length > 0 && props.movement.length > 0 ){\r\n          \r\n            let mappedResults = props.profile.map(x => {\r\n                return({\r\n                    profile: x,\r\n                    movements: props.movement.filter(xx => xx.suspectId === x.id)\r\n                })\r\n            })\r\n\r\n            // Accepts the array and key\r\n            const groupBy = (array, key) => {\r\n                // Return the end result\r\n                return array.reduce((result, currentValue) => {\r\n                // If an array already present for key, push it to the array. Else create an array and push the object\r\n                (result[currentValue[key]] = result[currentValue[key]] || []).push(\r\n                    currentValue\r\n                );\r\n                // Return the current iteration `result` value, this will be taken as next iteration `result` value and accumulate\r\n                return result;\r\n                }, {}); // empty object is the initial value for result object\r\n            };\r\n            \r\n            // Group by location address as key to the person array\r\n            const personGroupedByColor = groupBy(props.movement, 'locationShortaddress');\r\n            \r\n            // console.log(personGroupedByColor)\r\n\r\n            var UPoints = Object.keys(personGroupedByColor).map(function(key) {\r\n                if(personGroupedByColor[key].length === 1){\r\n                    let item = personGroupedByColor[key][0]\r\n                    return({\r\n                        'type': 'Feature',\r\n                        'properties': {\r\n                            'movementID':item.id,\r\n                            'enter': item.datetimeEntered,\r\n                            'leave': item.datetimeLeft,\r\n                            'placeID': item.locationShortaddress,\r\n                            'marker-symbol': '1',\r\n                            'marker-color': '#3bb2d0',\r\n                            'marker-size': 'large',\r\n                            'description':\r\n                                `<strong>${item.locationShortaddress}</strong><p>Time Entered: ${MainMap.getDatetime(item.datetimeEntered, 't')}</p><p>Time Left: ${MainMap.getDatetime(item.datetimeLeft, 't')}</p><p>Date: ${MainMap.getDatetime(item.datetimeLeft, 'd')}</p>`\r\n                            },\r\n                        'geometry': {\r\n                            'type': 'Point',\r\n                            'coordinates': [item.locationLong, item.locationLat],\r\n                        },\r\n                    })\r\n                }\r\n                else{\r\n                    let movementID = personGroupedByColor[key].map(x => x.id )\r\n                    // console.log(movementID)\r\n\r\n                    let enter = personGroupedByColor[key].map(x => x.datetimeEntered )\r\n                    let leave = personGroupedByColor[key].map(x => x.datetimeLeft)\r\n                    let placeID = key\r\n\r\n                    let text = `<strong>${key}</strong>`\r\n                    // console.log(placeID)\r\n                    personGroupedByColor[key].forEach(xx => {\r\n                        let name = props.profile.filter(x => x.id === xx.suspectId).map(x => {\r\n                            return(x.firstName + \" \" + x.lastName)\r\n                        })\r\n                        text += `<p>${name}</p>`\r\n                        text += `<p>Time Entered: ${MainMap.getDatetime(xx.datetimeEntered, 't')}</p><p>Time Left: ${MainMap.getDatetime(xx.datetimeLeft, 't')}</p><p>Date: ${MainMap.getDatetime(xx.datetimeLeft, 'd')}</p>`\r\n                    })\r\n\r\n                    // console.log(text)\r\n                    // let description = `<strong>${item.locationShortaddress}</strong><p>Time Entered: ${that.getDatetime(item.datetimeEntered, 't')}</p><p>Time Left: ${that.getDatetime(item.datetimeLeft, 't')}</p><p>Date: ${that.getDatetime(item.datetimeLeft, 'd')}</p>`\r\n\r\n                    return({\r\n                        'type': 'Feature',\r\n                        'properties': {\r\n                            'movementID': movementID,\r\n                            'enter': enter,\r\n                            'leave': leave,\r\n                            'placeID': placeID,\r\n                            'description': text,\r\n                            },\r\n                        'geometry': {\r\n                            'type': 'Point',\r\n                            'coordinates': [personGroupedByColor[key][0].locationLong, personGroupedByColor[key][0].locationLat]\r\n                        }\r\n                    })\r\n                }\r\n            });\r\n\r\n            for(var key in map.style.sourceCaches){\r\n                console.log(key)\r\n                if(key != 'composite'){\r\n                    map.removeLayer(key)\r\n                    if(key == \"placeIDs\"){\r\n                        map.off('click', 'placeIDs', function(e){\r\n\r\n                            var placeID = e.features[0].properties.placeID;           \r\n                            var description = e.features[0].properties.description;\r\n                            var movementID = e.features[0].properties.movementID;\r\n                            var enter = e.features[0].properties.enter;\r\n                            var leave = e.features[0].properties.leave;\r\n                            \r\n                            props.dataRetrieved(movementID)\r\n            \r\n\r\n                        });\r\n            \r\n                        map.off('mouseenter', 'placeIDs', function(e) {\r\n            \r\n                            // Change the cursor style as a UI indicator.\r\n                            map.getCanvas().style.cursor = 'pointer';\r\n                            \r\n                            var coordinates = e.features[0].geometry.coordinates.slice();\r\n                            var description = e.features[0].properties.description;\r\n            \r\n                            // Ensure that if the map is zoomed out such that multiple\r\n                            // copies of the feature are visible, the popup appears\r\n                            // over the copy being pointed to.\r\n                            while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {\r\n                                coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;\r\n                            }\r\n                            \r\n                            // Populate the popup and set its coordinates\r\n                            // based on the feature found.\r\n                            popup.setLngLat(coordinates).setHTML(description).addTo(map);\r\n                        });\r\n                            \r\n                        map.off('mouseleave', 'placeIDs', function() {\r\n                            map.getCanvas().style.cursor = '';\r\n                            popup.remove();\r\n                        });\r\n                    }\r\n                    map.removeSource(key)\r\n                }\r\n                // console.log(map.getStyle().layers)\r\n            }\r\n            \r\n            mappedResults.forEach(e => {\r\n\r\n                let lol = Math.floor(Math.random() * 101).toString()\r\n\r\n                let UMovements = e.movements.map(x => {\r\n                    return([x.locationLong, x.locationLat])\r\n                })\r\n\r\n                map.addSource(lol, {\r\n                    'type': 'geojson',\r\n                    'data': {\r\n                        'type': 'Feature',\r\n                        'properties': {},\r\n                        'geometry': {\r\n                            'type': 'LineString',\r\n                            'coordinates': UMovements\r\n                        }\r\n                    }\r\n                });\r\n\r\n                let color = MainMap.generateColor()\r\n                source = {...source, [color]: e.profile.firstName + \" \" + e.profile.lastName}\r\n                \r\n                map.addLayer({\r\n                    'id': lol,\r\n                    'type': 'line',\r\n                    'source': lol,\r\n                    'layout': {\r\n                        'line-join': 'round',\r\n                        'line-cap': 'round'\r\n                    },\r\n                    'paint': {\r\n                        'line-color': color,\r\n                        'line-width': 5\r\n                    }\r\n                });\r\n            })\r\n\r\n            map.addSource('placeIDs', {\r\n                'type': 'geojson',\r\n                'data': {\r\n                    'type': 'FeatureCollection',\r\n                    'features': UPoints\r\n                }\r\n            });\r\n\r\n            // Add a layer showing the places.\r\n            map.addLayer({\r\n                'id': 'placeIDs',\r\n                'type': 'symbol',\r\n                'source': 'placeIDs',\r\n                'layout': {\r\n                    // \"line-cap\": \"round\",\r\n                    // \"line-join\": \"round\"\r\n                    'icon-image': 'pulsing-dot',\r\n                    'icon-allow-overlap': true\r\n                }\r\n            });\r\n\r\n            map.on('click', 'placeIDs', function(e){\r\n\r\n                var movementID = e.features[0].properties.movementID;\r\n                \r\n                props.dataRetrieved(movementID)\r\n            });\r\n\r\n            map.on('mouseenter', 'placeIDs', function(e) {\r\n\r\n                // Change the cursor style as a UI indicator.\r\n                map.getCanvas().style.cursor = 'pointer';\r\n                \r\n                var coordinates = e.features[0].geometry.coordinates.slice();\r\n                var description = e.features[0].properties.description;\r\n\r\n                // Ensure that if the map is zoomed out such that multiple\r\n                // copies of the feature are visible, the popup appears\r\n                // over the copy being pointed to.\r\n                while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {\r\n                    coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;\r\n                }\r\n                \r\n                // Populate the popup and set its coordinates\r\n                // based on the feature found.\r\n                popup.setLngLat(coordinates).setHTML(description).addTo(map);\r\n            });\r\n                \r\n            map.on('mouseleave', 'placeIDs', function() {\r\n                map.getCanvas().style.cursor = '';\r\n                popup.remove();\r\n            });\r\n\r\n            counter += 1\r\n        } \r\n        \r\n        return true;\r\n    }\r\n\r\n    render(){\r\n        \r\n        let legend = []\r\n        for(var key in source){\r\n            legend.push(\r\n                <div>\r\n                     <span style={{height:\"18px\", width: \"18px\", backgroundColor: \"#bbb\", borderRadius: \"50%\", display: \"inline-block\"}}></span>\r\n                     <h5 style={{display: \"inline-block\", marginLeft:\"10px\"}}>Testing</h5>\r\n                </div>\r\n            )\r\n        }\r\n        return(\r\n            <>\r\n                <div>\r\n                   \r\n                    \r\n\r\n                    <span style={{height:\"18px\", width: \"18px\", backgroundColor: \"#bbb\", borderRadius: \"50%\", display: \"inline-block\"}}></span>\r\n                    <h5 style={{display: \"inline-block\", marginLeft:\"10px\"}}>Testing</h5>\r\n                </div>\r\n                <div style={{position:\"relative\",height:\"700px\", width:\"100%\"}}>\r\n                    <div ref={el => this.mapContainer = el} style={{position:\"reletive\", width:\"inherit\", height:\"inherit\"}}/>\r\n                </div>\r\n            </>\r\n            \r\n        )\r\n    }\r\n\r\n}\r\n\r\nexport default MainMap"]},"metadata":{},"sourceType":"module"}